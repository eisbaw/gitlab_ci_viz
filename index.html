<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitLab CI GANTT Visualizer</title>
    <link href="/static/vis-timeline-graph2d-8.3.1.min.css" rel="stylesheet" type="text/css" />
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        #visualization {
            width: 100%;
            height: 600px;
            border: 1px solid #ccc;
            background-color: white;
        }
        #status {
            margin-bottom: 20px;
            padding: 10px;
            background-color: #e8f4f8;
            border-radius: 4px;
        }
        #status.loading {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
        }
        #status.success {
            background-color: #d4edda;
            border-left: 4px solid #28a745;
        }
        #status.error {
            background-color: #f8d7da;
            border-left: 4px solid #dc3545;
        }
        #status.warning {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
        }
        h1 {
            margin-top: 0;
        }
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 3px solid rgba(0,0,0,.1);
            border-radius: 50%;
            border-top-color: #007bff;
            animation: spin 1s ease-in-out infinite;
            vertical-align: middle;
            margin-right: 8px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .error-details {
            margin-top: 10px;
            padding: 10px;
            background-color: rgba(255,255,255,0.5);
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
        }
        .resolution-steps {
            margin-top: 10px;
            padding-left: 20px;
        }
        .resolution-steps li {
            margin: 5px 0;
        }

        #last-update {
            margin-bottom: 10px;
            padding: 8px;
            background-color: #e9ecef;
            border-radius: 4px;
            font-size: 0.9em;
            color: #495057;
        }
        #last-update.refreshing {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
        }
        #last-update .timestamp {
            font-weight: bold;
        }
        #last-update .refresh-indicator {
            display: inline-block;
            margin-left: 10px;
            font-style: italic;
            color: #6c757d;
        }

        /* Status color palette */
        :root {
            --status-success-bg: #28a745;
            --status-success-border: #1e7e34;
            --status-failed-bg: #dc3545;
            --status-failed-border: #bd2130;
            --status-running-bg: #007bff;
            --status-running-border: #0056b3;
            --status-neutral-bg: #6c757d;
            --status-neutral-border: #545b62;
            --status-canceled-bg: #fd7e14;
            --status-canceled-border: #dc6502;
        }

        /* Pipeline status colors */
        .vis-item.pipeline-success {
            background-color: var(--status-success-bg);
            border-color: var(--status-success-border);
            color: white;
        }
        .vis-item.pipeline-failed {
            background-color: var(--status-failed-bg);
            border-color: var(--status-failed-border);
            color: white;
        }
        .vis-item.pipeline-running {
            background-color: var(--status-running-bg);
            border-color: var(--status-running-border);
            color: white;
        }
        .vis-item.pipeline-pending,
        .vis-item.pipeline-skipped,
        .vis-item.pipeline-manual,
        .vis-item.pipeline-created {
            background-color: var(--status-neutral-bg);
            border-color: var(--status-neutral-border);
            color: white;
        }
        .vis-item.pipeline-canceled,
        .vis-item.pipeline-cancelled {
            background-color: var(--status-canceled-bg);
            border-color: var(--status-canceled-border);
            color: white;
        }

        /* Job status colors */
        .vis-item.job-success {
            background-color: var(--status-success-bg);
            border-color: var(--status-success-border);
            color: white;
        }
        .vis-item.job-failed {
            background-color: var(--status-failed-bg);
            border-color: var(--status-failed-border);
            color: white;
        }
        .vis-item.job-running {
            background-color: var(--status-running-bg);
            border-color: var(--status-running-border);
            color: white;
        }
        .vis-item.job-pending,
        .vis-item.job-skipped,
        .vis-item.job-manual,
        .vis-item.job-created {
            background-color: var(--status-neutral-bg);
            border-color: var(--status-neutral-border);
            color: white;
        }
        .vis-item.job-canceled,
        .vis-item.job-cancelled {
            background-color: var(--status-canceled-bg);
            border-color: var(--status-canceled-border);
            color: white;
        }
    </style>
    <!-- CONFIG object injected here by serve.py as <script> tag -->
</head>
<body>
    <h1>GitLab CI GANTT Visualizer</h1>
    <div id="last-update" style="display: none;">
        Last updated: <span class="timestamp">Never</span>
        <span class="refresh-indicator"></span>
    </div>
    <div id="status">Loading configuration...</div>
    <div id="visualization"></div>

    <script src="/static/vis-timeline-graph2d-8.3.1.min.js"></script>
    <script src="/static/logger.js"></script>
    <script src="/static/error-formatter.js"></script>
    <script src="/static/api-client.js"></script>
    <script src="/static/data-transformer.js"></script>
    <script>
        // Global timeline instance
        let timeline = null;

        // Global API client instance
        let apiClient = null;

        // Auto-refresh state
        let refreshTimer = null;

        /**
         * Update last update timestamp display
         */
        function updateLastUpdateTimestamp(isRefreshing = false) {
            const lastUpdateDiv = document.getElementById('last-update');
            const timestampSpan = lastUpdateDiv.querySelector('.timestamp');
            const refreshIndicator = lastUpdateDiv.querySelector('.refresh-indicator');

            // Show the timestamp div
            lastUpdateDiv.style.display = 'block';

            if (isRefreshing) {
                lastUpdateDiv.classList.add('refreshing');
                refreshIndicator.textContent = '(refreshing...)';
            } else {
                lastUpdateDiv.classList.remove('refreshing');
                const now = new Date();
                const dateStr = now.toLocaleDateString();
                const timeStr = now.toLocaleTimeString();
                timestampSpan.textContent = `${dateStr} ${timeStr}`;

                // Show next refresh time if auto-refresh is enabled
                if (CONFIG.refreshInterval && CONFIG.refreshInterval > 0) {
                    const nextRefreshSeconds = CONFIG.refreshInterval;
                    const nextRefreshTime = new Date(now.getTime() + nextRefreshSeconds * 1000);
                    refreshIndicator.textContent = `(next refresh at ${nextRefreshTime.toLocaleTimeString()})`;
                } else {
                    refreshIndicator.textContent = '(auto-refresh disabled)';
                }
            }
        }

        /**
         * Update status display with appropriate styling
         */
        function updateStatus(message, type = 'info', details = null) {
            const statusDiv = document.getElementById('status');
            statusDiv.className = type;

            let html = message;
            if (details) {
                html += `<div class="error-details">${escapeHTML(details)}</div>`;
            }
            statusDiv.innerHTML = html;
        }

        /**
         * Show loading indicator
         */
        function showLoading(message) {
            updateStatus(`<span class="spinner"></span>${message}`, 'loading');
        }

        /**
         * Display configuration status and initialize timeline
         */
        document.addEventListener('DOMContentLoaded', function() {
            const statusDiv = document.getElementById('status');

            // Initialize API client
            try {
                apiClient = new GitLabAPIClient();

                let statusHtml = '<strong>Configuration loaded successfully:</strong><br>';
                statusHtml += `GitLab URL: ${CONFIG.gitlabUrl}<br>`;
                statusHtml += `Time range: since ${CONFIG.since}<br>`;

                if (CONFIG.groupId) {
                    statusHtml += `Group ID: ${CONFIG.groupId}<br>`;
                } else if (CONFIG.projectIds) {
                    statusHtml += `Project IDs: ${CONFIG.projectIds.join(', ')}<br>`;
                }

                statusHtml += `Token: ✓ Present<br>`;
                statusHtml += `API Client: ✓ Initialized<br>`;
                updateStatus(statusHtml, 'success');
            } catch (error) {
                const errorHtml = `<strong>Configuration Error</strong><br>${error.message}`;
                updateStatus(errorHtml, 'error');
                return; // Stop initialization if API client fails
            }

            // Test vis.js library
            if (typeof vis === 'undefined') {
                const errorHtml = '<strong>Library Error</strong><br>vis.js library failed to load';
                updateStatus(errorHtml, 'error', 'Check browser console for details');
                return;
            }

            // Test DataTransformer module
            if (typeof DataTransformer === 'undefined') {
                const errorHtml = '<strong>Library Error</strong><br>DataTransformer module failed to load';
                updateStatus(errorHtml, 'error', 'Check browser console for details');
                return;
            }

            const statusDiv2 = document.getElementById('status');
            statusDiv2.innerHTML += 'vis.js library: ✓ Loaded<br>';
            statusDiv2.innerHTML += 'DataTransformer: ✓ Loaded';

            // Initialize Timeline
            initializeTimeline();

            // Fetch and render data
            fetchAndRender();

            // Schedule auto-refresh if enabled
            scheduleAutoRefresh();
        });

        /**
         * Initialize vis.js Timeline component with GANTT chart configuration
         */
        function initializeTimeline() {
            const container = document.getElementById('visualization');

            // Cleanup if timeline already exists (defensive, idempotent)
            if (timeline) {
                timeline.destroy();
            }

            // Create empty datasets for now (will be populated by API data)
            const items = new vis.DataSet([]);
            const groups = new vis.DataSet([]);

            // Timeline options for GANTT chart style
            // Show dates in day/month context, times in HH:mm format
            // Helps operators quickly identify when pipelines ran
            const options = {
                // Stack items within groups
                stack: true,

                // Show current time line
                showCurrentTime: true,

                // Time axis format
                format: {
                    minorLabels: {
                        minute: 'HH:mm',
                        hour: 'HH:mm'
                    },
                    majorLabels: {
                        minute: 'ddd D MMMM',
                        hour: 'ddd D MMMM',
                        day: 'MMMM YYYY'
                    }
                },

                // Orientation
                orientation: 'top',

                // Enable grouping
                groupOrder: 'content',

                // Enable dragging and zooming
                zoomable: true,
                moveable: true,

                // Tooltip
                tooltip: {
                    followMouse: true,
                    overflowMethod: 'cap'
                },

                // Margins
                margin: {
                    item: {
                        horizontal: 10,
                        vertical: 5
                    }
                }
            };

            // Create Timeline instance
            timeline = new vis.Timeline(container, items, groups, options);

            console.log('Timeline initialized successfully');
        }


        /**
         * Schedule auto-refresh if enabled in configuration
         */
        function scheduleAutoRefresh() {
            // Clear any existing timer
            if (refreshTimer) {
                clearTimeout(refreshTimer);
                refreshTimer = null;
            }

            // Check if auto-refresh is enabled
            if (!CONFIG.refreshInterval || CONFIG.refreshInterval <= 0) {
                console.log('Auto-refresh disabled (refreshInterval <= 0)');
                return;
            }

            console.log(`Scheduling auto-refresh in ${CONFIG.refreshInterval} seconds`);

            // Schedule next refresh
            refreshTimer = setTimeout(async () => {
                console.log('Auto-refresh triggered');
                await fetchAndRender(true); // Pass isRefresh=true
                scheduleAutoRefresh(); // Schedule next refresh
            }, CONFIG.refreshInterval * 1000);
        }

        /**
         * Fetch GitLab data and render on timeline
         *
         * Orchestrates the complete data flow:
         * 1. Fetch projects from GitLab API
         * 2. Fetch pipelines for those projects
         * 3. Fetch jobs for those pipelines
         * 4. Transform to vis.js format
         * 5. Update timeline with transformed data
         *
         * @param {boolean} isRefresh - If true, preserve timeline zoom/pan state
         */
        async function fetchAndRender(isRefresh = false) {
            try {
                // Indicate refresh is in progress
                if (isRefresh) {
                    updateLastUpdateTimestamp(true);
                }

                // Save current timeline window if refreshing
                let savedWindow = null;
                if (isRefresh && timeline) {
                    savedWindow = timeline.getWindow();
                }

                // Step 1: Fetch projects
                const loadingMsg = isRefresh ? 'Refreshing data...' : 'Fetching projects from GitLab...';
                showLoading(loadingMsg);
                const projects = await apiClient.fetchProjects();

                // Create project map for quick lookup
                const projectMap = new Map();
                projects.forEach(p => projectMap.set(p.id, p));

                // Step 2: Fetch pipelines
                showLoading(`Fetching pipelines from ${projects.length} projects...`);
                const pipelines = await apiClient.fetchPipelines(projects, CONFIG.updatedAfter);

                if (pipelines.length === 0) {
                    if (isRefresh) {
                        // Update timestamp even when no new pipelines
                        updateLastUpdateTimestamp(false);

                        // Expected: no new updates since last refresh
                        updateStatus(
                            `<strong>No new pipelines</strong><br>` +
                            `No pipeline updates since ${CONFIG.since}.<br>` +
                            'This is normal - the chart will update automatically when new pipelines run.',
                            'success'
                        );
                    } else {
                        // Actual problem: no data in time range
                        updateStatus(
                            '<strong>No pipelines found</strong><br>' +
                            `No pipelines found in the specified time range (since ${CONFIG.since}).<br>` +
                            'Try adjusting the time range or check if pipelines exist in the configured projects.',
                            'warning'
                        );
                    }
                    return;
                }

                // Step 3: Fetch jobs
                showLoading(`Fetching jobs from ${pipelines.length} pipelines...`);
                const jobs = await apiClient.fetchJobs(pipelines);

                // Step 4: Transform to vis.js format
                showLoading('Transforming data for visualization...');
                const transformed = DataTransformer.transform(pipelines, jobs);

                // Step 5: Enrich pipeline items with project names
                const enrichedItems = transformed.items.map(item => {
                    // Check if this is a pipeline item (not a job item)
                    if (item.id.startsWith('pipeline-item-')) {
                        const pipelineId = parseInt(item.id.replace('pipeline-item-', ''), 10);
                        const pipeline = pipelines.find(p => p.id === pipelineId);

                        if (!pipeline) {
                            throw new Error(
                                `Data integrity error: Timeline item references unknown pipeline ${pipelineId}. ` +
                                `This should never happen - indicates bug in DataTransformer.`
                            );
                        }

                        const project = projectMap.get(pipeline.project_id);
                        if (!project) {
                            throw new Error(
                                `Data integrity error: Pipeline ${pipelineId} references unknown project ${pipeline.project_id}. ` +
                                `Available projects: [${Array.from(projectMap.keys()).join(', ')}]`
                            );
                        }

                        // Return enriched item (immutable)
                        return {
                            ...item,
                            content: `${project.name} #${pipeline.id}`
                        };
                    }

                    // Return non-pipeline items unchanged
                    return item;
                });

                // Step 6: Update timeline
                showLoading('Rendering timeline...');
                timeline.setGroups(transformed.groups);
                timeline.setItems(enrichedItems);

                // Restore window if refreshing
                if (savedWindow) {
                    timeline.setWindow(savedWindow.start, savedWindow.end);
                }

                // Update last update timestamp
                updateLastUpdateTimestamp(false);

                // Success message
                const actionWord = isRefresh ? 'refreshed' : 'loaded';
                const successMessage =
                    `<strong>Data ${actionWord} successfully</strong><br>` +
                    `Loaded ${projects.length} projects, ${pipelines.length} pipelines, ${jobs.length} jobs<br>` +
                    `Time range: ${CONFIG.since}`;
                updateStatus(successMessage, 'success');

            } catch (error) {
                console.error('Error fetching and rendering data:', error);
                const errorMessage = formatError(error);
                updateStatus(errorMessage, 'error');

                // Log full error details for debugging
                if (error.originalError) {
                    console.error('Original error:', error.originalError);
                }
            }
        }
    </script>
</body>
</html>
