<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitLab CI GANTT Visualizer</title>
    <link href="/static/vis-timeline-graph2d-8.3.1.min.css" rel="stylesheet" type="text/css" />
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        #visualization {
            width: 100%;
            height: 600px;
            border: 1px solid #ccc;
            background-color: white;
        }
        #status {
            margin-bottom: 20px;
            padding: 10px;
            background-color: #e8f4f8;
            border-radius: 4px;
        }
        #status.loading {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
        }
        #status.success {
            background-color: #d4edda;
            border-left: 4px solid #28a745;
        }
        #status.error {
            background-color: #f8d7da;
            border-left: 4px solid #dc3545;
        }
        #status.warning {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
        }
        h1 {
            margin-top: 0;
        }
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 3px solid rgba(0,0,0,.1);
            border-radius: 50%;
            border-top-color: #007bff;
            animation: spin 1s ease-in-out infinite;
            vertical-align: middle;
            margin-right: 8px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .error-details {
            margin-top: 10px;
            padding: 10px;
            background-color: rgba(255,255,255,0.5);
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
        }
        .resolution-steps {
            margin-top: 10px;
            padding-left: 20px;
        }
        .resolution-steps li {
            margin: 5px 0;
        }

        #time-range-label {
            margin-bottom: 10px;
            padding: 8px;
            background-color: #d1ecf1;
            border-left: 4px solid #0c5460;
            border-radius: 4px;
            font-size: 0.95em;
            color: #0c5460;
            font-weight: bold;
        }
        #time-range-label .time-range {
            font-weight: normal;
            color: #155724;
        }

        #last-update {
            margin-bottom: 10px;
            padding: 8px;
            background-color: #e9ecef;
            border-radius: 4px;
            font-size: 0.9em;
            color: #495057;
        }
        #last-update.refreshing {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
        }
        #last-update .timestamp {
            font-weight: bold;
        }
        #last-update .refresh-indicator {
            display: inline-block;
            margin-left: 10px;
            font-style: italic;
            color: #6c757d;
        }

        /* Status color palette */
        :root {
            --status-success-bg: #28a745;
            --status-success-border: #1e7e34;
            --status-failed-bg: #dc3545;
            --status-failed-border: #bd2130;
            --status-running-bg: #007bff;
            --status-running-border: #0056b3;
            --status-neutral-bg: #6c757d;
            --status-neutral-border: #545b62;
            --status-canceled-bg: #fd7e14;
            --status-canceled-border: #dc6502;
        }

        /* Pipeline status colors */
        .vis-item.pipeline-success {
            background-color: var(--status-success-bg);
            border-color: var(--status-success-border);
            color: white;
        }
        .vis-item.pipeline-failed {
            background-color: var(--status-failed-bg);
            border-color: var(--status-failed-border);
            color: white;
        }
        .vis-item.pipeline-running {
            background-color: var(--status-running-bg);
            border-color: var(--status-running-border);
            color: white;
        }
        .vis-item.pipeline-pending,
        .vis-item.pipeline-skipped,
        .vis-item.pipeline-manual,
        .vis-item.pipeline-created {
            background-color: var(--status-neutral-bg);
            border-color: var(--status-neutral-border);
            color: white;
        }
        .vis-item.pipeline-canceled,
        .vis-item.pipeline-cancelled {
            background-color: var(--status-canceled-bg);
            border-color: var(--status-canceled-border);
            color: white;
        }

        /* Job status colors */
        .vis-item.job-success {
            background-color: var(--status-success-bg);
            border-color: var(--status-success-border);
            color: white;
        }
        .vis-item.job-failed {
            background-color: var(--status-failed-bg);
            border-color: var(--status-failed-border);
            color: white;
        }
        .vis-item.job-running {
            background-color: var(--status-running-bg);
            border-color: var(--status-running-border);
            color: white;
        }
        .vis-item.job-pending,
        .vis-item.job-skipped,
        .vis-item.job-manual,
        .vis-item.job-created {
            background-color: var(--status-neutral-bg);
            border-color: var(--status-neutral-border);
            color: white;
        }
        .vis-item.job-canceled,
        .vis-item.job-cancelled {
            background-color: var(--status-canceled-bg);
            border-color: var(--status-canceled-border);
            color: white;
        }

        /* Clickable items cursor */
        .vis-item.pipeline-success,
        .vis-item.pipeline-failed,
        .vis-item.pipeline-running,
        .vis-item.pipeline-pending,
        .vis-item.pipeline-skipped,
        .vis-item.pipeline-manual,
        .vis-item.pipeline-created,
        .vis-item.pipeline-canceled,
        .vis-item.pipeline-cancelled,
        .vis-item.job-success,
        .vis-item.job-failed,
        .vis-item.job-running,
        .vis-item.job-pending,
        .vis-item.job-skipped,
        .vis-item.job-manual,
        .vis-item.job-created,
        .vis-item.job-canceled,
        .vis-item.job-cancelled {
            cursor: pointer;
        }

        /* Resource contention background shading */
        .vis-item.contention-low {
            background-color: rgba(255, 235, 59, 0.15);
            border: none;
        }
        .vis-item.contention-medium {
            background-color: rgba(255, 152, 0, 0.20);
            border: none;
        }
        .vis-item.contention-high {
            background-color: rgba(244, 67, 54, 0.25);
            border: none;
        }
        .vis-item.contention-critical {
            background-color: rgba(183, 28, 28, 0.30);
            border: none;
        }

        /* Filter controls */
        #filter-controls {
            margin-bottom: 15px;
            padding: 12px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }
        #filter-controls h3 {
            margin: 0 0 10px 0;
            font-size: 1em;
            color: #495057;
        }
        .filter-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        .filter-checkbox {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .filter-checkbox input[type="checkbox"] {
            cursor: pointer;
            width: 18px;
            height: 18px;
        }
        .filter-checkbox label {
            cursor: pointer;
            user-select: none;
            font-size: 0.95em;
        }
        .filter-actions {
            margin-left: auto;
        }
        .filter-actions button {
            padding: 5px 12px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
        }
        .filter-actions button:hover {
            background-color: #5a6268;
        }
        .job-search-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #dee2e6;
        }
        .job-search-input {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .job-search-input input[type="text"] {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #ced4da;
            border-radius: 3px;
            font-size: 0.95em;
            max-width: 300px;
        }
        .job-search-input input[type="text"]:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
        }
        .job-search-input button {
            padding: 6px 12px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
        }
        .job-search-input button:hover {
            background-color: #5a6268;
        }
    </style>
    <!-- CONFIG object injected here by serve.py as <script> tag -->
</head>
<body>
    <h1>GitLab CI GANTT Visualizer</h1>
    <div id="time-range-label" style="display: none;">
        Activity Window: <span class="time-range">Loading...</span>
    </div>
    <div id="last-update" style="display: none;">
        Last updated: <span class="timestamp">Never</span>
        <span class="refresh-indicator"></span>
    </div>
    <div id="filter-controls" style="display: none;">
        <h3>Filter by Pipeline Status</h3>
        <div class="filter-checkboxes">
            <div class="filter-checkbox">
                <input type="checkbox" id="filter-success" value="success" checked>
                <label for="filter-success">Success</label>
            </div>
            <div class="filter-checkbox">
                <input type="checkbox" id="filter-failed" value="failed" checked>
                <label for="filter-failed">Failed</label>
            </div>
            <div class="filter-checkbox">
                <input type="checkbox" id="filter-running" value="running" checked>
                <label for="filter-running">Running</label>
            </div>
            <div class="filter-checkbox">
                <input type="checkbox" id="filter-pending" value="pending" checked>
                <label for="filter-pending">Pending</label>
            </div>
            <div class="filter-checkbox">
                <input type="checkbox" id="filter-canceled" value="canceled" checked>
                <label for="filter-canceled">Canceled</label>
            </div>
            <div class="filter-actions">
                <button id="clear-filters">Clear All</button>
                <button id="reset-filters">Reset</button>
            </div>
        </div>
        <div class="job-search-section">
            <h3>Filter by Job Name</h3>
            <div class="job-search-input">
                <input type="text" id="job-search-input" placeholder="Search job names (e.g., 'build', 'test')...">
                <button id="clear-job-search">Clear</button>
            </div>
        </div>
    </div>
    <div id="status">Loading configuration...</div>
    <div id="visualization"></div>

    <script src="/static/vis-timeline-graph2d-8.3.1.min.js"></script>
    <script src="/static/logger.js"></script>
    <script src="/static/error-formatter.js"></script>
    <script src="/static/api-client.js"></script>
    <script src="/static/data-transformer.js"></script>
    <script src="/static/contention-analyzer.js"></script>
    <script>
        // Global timeline instance
        let timeline = null;

        // Global API client instance
        let apiClient = null;

        // Auto-refresh state
        let refreshTimer = null;

        // Filter state encapsulation
        const FilterState = {
            active: new Set(['success', 'failed', 'running', 'pending', 'canceled']),

            reset() {
                this.active.clear();
                ['success', 'failed', 'running', 'pending', 'canceled'].forEach(s => this.active.add(s));
            },

            clear() {
                this.active.clear();
            },

            has(status) {
                return this.active.has(status);
            },

            add(status) {
                this.active.add(status);
            },

            delete(status) {
                this.active.delete(status);
            }
        };

        // Job search state encapsulation
        const JobSearchState = {
            searchTerm: '',

            set(term) {
                if (typeof term !== 'string') {
                    throw new TypeError(`JobSearchState.set() expects string, got ${typeof term}`);
                }
                this.searchTerm = term.toLowerCase().trim();
            },

            clear() {
                this.searchTerm = '';
            },

            isEmpty() {
                return this.searchTerm === '';
            },

            matches(jobName) {
                if (this.isEmpty()) {
                    return true; // No filter, match all
                }
                if (typeof jobName !== 'string') {
                    console.warn('JobSearchState.matches() received non-string job name:', jobName);
                    return false;
                }
                return jobName.toLowerCase().includes(this.searchTerm);
            }
        };

        // Store unfiltered data for re-filtering (vis.js DataSets are primary storage)
        let unfilteredPipelines = [];
        let unfilteredJobs = [];
        let projectMap = new Map();

        /**
         * Compute filtered data based on current filter state
         * Single authoritative function for applying both pipeline status and job name filters
         * @returns {Object} {filteredPipelines, filteredJobs}
         */
        function computeFilteredData() {
            // Filter pipelines by status
            const filteredPipelines = unfilteredPipelines.filter(pipeline => {
                return FilterState.has(normalizeStatus(pipeline.status));
            });

            // Filter jobs by pipeline membership and job name
            const filteredPipelineIds = new Set(filteredPipelines.map(p => p.id));
            const filteredJobs = unfilteredJobs.filter(job => {
                // First check if job belongs to a filtered pipeline
                if (!filteredPipelineIds.has(job.pipeline_id)) {
                    return false;
                }
                // Then check if job name matches search term
                return JobSearchState.matches(job.name);
            });

            // Log filtering results for observability
            const jobsBeforeNameFilter = unfilteredJobs.filter(job =>
                filteredPipelineIds.has(job.pipeline_id)
            ).length;

            console.log(
                `Applied filters: ${unfilteredPipelines.length} pipelines → ${filteredPipelines.length} filtered | ` +
                `${jobsBeforeNameFilter} jobs → ${filteredJobs.length} filtered ` +
                `(search: '${JobSearchState.searchTerm || '(none)'}')`
            );

            return { filteredPipelines, filteredJobs };
        }

        /**
         * Normalize pipeline status to handle GitLab API inconsistencies
         * @param {string} status - Raw status from GitLab API
         * @returns {string} Normalized status
         */
        function normalizeStatus(status) {
            return status === 'cancelled' ? 'canceled' : status;
        }

        /**
         * Enrich timeline items with project context and metadata
         * @param {Array} items - Raw timeline items from DataTransformer
         * @param {Array} pipelines - Pipeline data to look up
         * @param {Array} jobs - Job data to look up
         * @param {Map} projectMap - Map of project ID to project object
         * @returns {Array} Enriched items with project info and URLs
         */
        function enrichTimelineItems(items, pipelines, jobs, projectMap) {
            return items.map(item => {
                // Enrich pipeline items
                if (item.id.startsWith('pipeline-item-')) {
                    const pipelineId = parseInt(item.id.replace('pipeline-item-', ''), 10);
                    const pipeline = pipelines.find(p => p.id === pipelineId);

                    if (!pipeline) {
                        throw new Error(
                            `Data integrity error: Timeline item references unknown pipeline ${pipelineId}. ` +
                            `This should never happen - indicates bug in DataTransformer.`
                        );
                    }

                    const project = projectMap.get(pipeline.project_id);
                    if (!project) {
                        throw new Error(
                            `Data integrity error: Pipeline ${pipelineId} references unknown project ${pipeline.project_id}. ` +
                            `Available projects: [${Array.from(projectMap.keys()).join(', ')}]`
                        );
                    }

                    const enrichedTooltip = `Project: ${project.name}\n${item.title}`;
                    const projectColor = getProjectColor(project.name);

                    return {
                        ...item,
                        content: `${project.name} #${pipeline.id}`,
                        title: enrichedTooltip,
                        style: `border-left: 4px solid ${projectColor};`,
                        projectId: pipeline.project_id,
                        pipelineId: pipeline.id
                    };
                }

                // Enrich job items
                if (item.id.startsWith('job-item-')) {
                    const jobId = parseInt(item.id.replace('job-item-', ''), 10);

                    // Find the job in the jobs array
                    const job = jobs.find(j => j.id === jobId);
                    if (job) {
                        return {
                            ...item,
                            projectId: job.project_id,
                            pipelineId: job.pipeline_id,
                            jobId: job.id
                        };
                    }
                }

                // Return other items unchanged (e.g., background items)
                return item;
            });
        }

        /**
         * Generate consistent color for project based on project name
         * Uses simple hash function to generate HSL color with good contrast
         */
        function getProjectColor(projectName) {
            // Simple hash function
            let hash = 0;
            for (let i = 0; i < projectName.length; i++) {
                hash = projectName.charCodeAt(i) + ((hash << 5) - hash);
            }

            // Generate HSL color with:
            // - Hue: 0-360 based on hash
            // - Saturation: 45-55% for subtle but visible differentiation
            // - Lightness: 60-70% for good contrast with text
            const hue = Math.abs(hash % 360);
            const saturation = 50;
            const lightness = 65;

            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        /**
         * Initialize filter controls event handlers
         */
        function initializeFilterControls() {
            const filterControls = document.getElementById('filter-controls');
            if (!filterControls) {
                throw new Error('Critical initialization error: filter-controls element not found in DOM');
            }

            // Show filter controls
            filterControls.style.display = 'block';

            // Get all filter checkboxes
            const checkboxes = filterControls.querySelectorAll('input[type="checkbox"]');

            // Add change event listeners to all checkboxes
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const status = this.value;
                    if (this.checked) {
                        FilterState.add(status);
                    } else {
                        FilterState.delete(status);
                    }
                    console.log('Filter changed:', Array.from(FilterState.active));
                    applyFilters();
                });
            });

            // Clear all button - uncheck all filters
            const clearButton = document.getElementById('clear-filters');
            if (clearButton) {
                clearButton.addEventListener('click', function() {
                    checkboxes.forEach(checkbox => {
                        checkbox.checked = false;
                    });
                    FilterState.clear();
                    console.log('All filters cleared');
                    applyFilters();
                });
            }

            // Reset button - check all filters
            const resetButton = document.getElementById('reset-filters');
            if (resetButton) {
                resetButton.addEventListener('click', function() {
                    checkboxes.forEach(checkbox => {
                        checkbox.checked = true;
                    });
                    FilterState.reset();
                    console.log('Filters reset to default (all checked)');
                    applyFilters();
                });
            }

            // Job search input event handler
            const jobSearchInput = document.getElementById('job-search-input');
            if (jobSearchInput) {
                // Debounce search to avoid too many re-renders while typing
                let searchTimeout = null;
                jobSearchInput.addEventListener('input', function() {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        JobSearchState.set(this.value);
                        console.log('Job search term:', JobSearchState.searchTerm || '(empty)');
                        applyFilters();
                    }, 300); // 300ms debounce
                });
            }

            // Clear job search button
            const clearJobSearchButton = document.getElementById('clear-job-search');
            if (clearJobSearchButton) {
                clearJobSearchButton.addEventListener('click', function() {
                    const input = document.getElementById('job-search-input');
                    if (input) {
                        input.value = '';
                    }
                    JobSearchState.clear();
                    console.log('Job search cleared');
                    applyFilters();
                });
            }

            console.log('Filter controls initialized');
        }

        /**
         * Apply active filters to timeline data
         * Re-renders timeline with filtered pipelines and their jobs
         */
        function applyFilters() {
            if (!timeline || unfilteredPipelines.length === 0) {
                console.log('No data to filter yet');
                return;
            }

            // Use shared filter computation
            const { filteredPipelines, filteredJobs } = computeFilteredData();

            // Transform filtered data (pass projectMap for project-based grouping)
            const transformed = DataTransformer.transform(filteredPipelines, filteredJobs, projectMap);

            // Calculate contention for filtered pipelines
            const domainModel = DataTransformer.transformToDomainModel(filteredPipelines, filteredJobs, projectMap);
            const allPipelines = domainModel.flatMap(user => user.pipelines);
            const contentionPeriods = ContentionAnalyzer.calculateContentionPeriods(allPipelines);
            const contentionBackgrounds = ContentionAnalyzer.toVisBackgroundItems(contentionPeriods);

            // Enrich items with project information (using shared function)
            const enrichedItems = enrichTimelineItems(transformed.items, filteredPipelines, filteredJobs, projectMap);

            // Combine with contention backgrounds
            const allItems = [...enrichedItems, ...contentionBackgrounds];

            // Update timeline (auto-fits to new data)
            // Note: Window state is NOT preserved across filter operations. This is intentional -
            // preserving viewport state across filtered data creates misalignment and hidden state.
            // Timeline auto-fits to show all current data.
            timeline.setGroups(transformed.groups);
            timeline.setItems(allItems);

            console.log('Filters applied successfully');
        }

        /**
         * Update time range label to show activity window
         * Uses DataTransformer.formatTimeRange() for business logic
         */
        function updateTimeRangeLabel() {
            const timeRangeDiv = document.getElementById('time-range-label');
            const timeRangeSpan = timeRangeDiv.querySelector('.time-range');

            // Show the time range div
            timeRangeDiv.style.display = 'block';

            // Use DataTransformer for time range calculation (fail-fast on invalid input)
            const { durationLabel, startDateStr, endDateStr } =
                DataTransformer.formatTimeRange(CONFIG.updatedAfter);

            timeRangeSpan.textContent = `${durationLabel}: ${startDateStr} - ${endDateStr}`;
        }

        /**
         * Update last update timestamp display
         */
        function updateLastUpdateTimestamp(isRefreshing = false) {
            const lastUpdateDiv = document.getElementById('last-update');
            const timestampSpan = lastUpdateDiv.querySelector('.timestamp');
            const refreshIndicator = lastUpdateDiv.querySelector('.refresh-indicator');

            // Show the timestamp div
            lastUpdateDiv.style.display = 'block';

            if (isRefreshing) {
                lastUpdateDiv.classList.add('refreshing');
                refreshIndicator.textContent = '(refreshing...)';
            } else {
                lastUpdateDiv.classList.remove('refreshing');
                const now = new Date();
                const dateStr = now.toLocaleDateString();
                const timeStr = now.toLocaleTimeString();
                timestampSpan.textContent = `${dateStr} ${timeStr}`;

                // Show next refresh time if auto-refresh is enabled
                if (CONFIG.refreshInterval && CONFIG.refreshInterval > 0) {
                    const nextRefreshSeconds = CONFIG.refreshInterval;
                    const nextRefreshTime = new Date(now.getTime() + nextRefreshSeconds * 1000);
                    refreshIndicator.textContent = `(next refresh at ${nextRefreshTime.toLocaleTimeString()})`;
                } else {
                    refreshIndicator.textContent = '(auto-refresh disabled)';
                }
            }
        }

        /**
         * Update status display with appropriate styling
         */
        function updateStatus(message, type = 'info', details = null) {
            const statusDiv = document.getElementById('status');
            statusDiv.className = type;

            let html = message;
            if (details) {
                html += `<div class="error-details">${escapeHTML(details)}</div>`;
            }
            statusDiv.innerHTML = html;
        }

        /**
         * Show loading indicator
         */
        function showLoading(message) {
            updateStatus(`<span class="spinner"></span>${message}`, 'loading');
        }

        /**
         * Display configuration status and initialize timeline
         */
        document.addEventListener('DOMContentLoaded', function() {
            const statusDiv = document.getElementById('status');

            // Initialize API client
            try {
                apiClient = new GitLabAPIClient(CONFIG);

                let statusHtml = '<strong>Configuration loaded successfully:</strong><br>';
                statusHtml += `GitLab URL: ${CONFIG.gitlabUrl}<br>`;
                statusHtml += `Time range: since ${CONFIG.since}<br>`;

                if (CONFIG.groupId) {
                    statusHtml += `Group ID: ${CONFIG.groupId}<br>`;
                } else if (CONFIG.projectIds) {
                    statusHtml += `Project IDs: ${CONFIG.projectIds.join(', ')}<br>`;
                }

                statusHtml += `Token: ✓ Present<br>`;
                statusHtml += `API Client: ✓ Initialized<br>`;
                updateStatus(statusHtml, 'success');
            } catch (error) {
                const errorHtml = `<strong>Configuration Error</strong><br>${error.message}`;
                updateStatus(errorHtml, 'error');
                return; // Stop initialization if API client fails
            }

            // Test vis.js library
            if (typeof vis === 'undefined') {
                const errorHtml = '<strong>Library Error</strong><br>vis.js library failed to load';
                updateStatus(errorHtml, 'error', 'Check browser console for details');
                return;
            }

            // Test DataTransformer module
            if (typeof DataTransformer === 'undefined') {
                const errorHtml = '<strong>Library Error</strong><br>DataTransformer module failed to load';
                updateStatus(errorHtml, 'error', 'Check browser console for details');
                return;
            }

            const statusDiv2 = document.getElementById('status');
            statusDiv2.innerHTML += 'vis.js library: ✓ Loaded<br>';
            statusDiv2.innerHTML += 'DataTransformer: ✓ Loaded';

            // Update time range label
            updateTimeRangeLabel();

            // Initialize Timeline
            initializeTimeline();

            // Initialize filter controls
            initializeFilterControls();

            // Fetch and render data
            fetchAndRender();

            // Schedule auto-refresh if enabled
            scheduleAutoRefresh();
        });

        /**
         * Initialize vis.js Timeline component with GANTT chart configuration
         */
        function initializeTimeline() {
            const container = document.getElementById('visualization');

            // Cleanup if timeline already exists (defensive, idempotent)
            if (timeline) {
                timeline.destroy();
            }

            // Create empty datasets for now (will be populated by API data)
            const items = new vis.DataSet([]);
            const groups = new vis.DataSet([]);

            // Timeline options for GANTT chart style
            // Show dates in day/month context, times in HH:mm format
            // Helps operators quickly identify when pipelines ran
            const options = {
                // Stack items within groups
                stack: true,

                // Show current time line
                showCurrentTime: true,

                // Time axis format
                format: {
                    minorLabels: {
                        minute: 'HH:mm',
                        hour: 'HH:mm'
                    },
                    majorLabels: {
                        minute: 'ddd D MMMM',
                        hour: 'ddd D MMMM',
                        day: 'MMMM YYYY'
                    }
                },

                // Orientation
                orientation: 'top',

                // Enable grouping
                groupOrder: 'content',

                // Enable dragging and zooming
                zoomable: true,
                moveable: true,

                // Tooltip
                tooltip: {
                    followMouse: true,
                    overflowMethod: 'cap'
                },

                // Margins
                margin: {
                    item: {
                        horizontal: 10,
                        vertical: 5
                    }
                }
            };

            // Create Timeline instance
            timeline = new vis.Timeline(container, items, groups, options);

            // Add click event listener for opening GitLab pages
            timeline.on('click', function(properties) {
                // Check if an item was clicked (not just the background)
                if (properties.item) {
                    const itemId = properties.item;
                    const items = timeline.itemsData;
                    const item = items.get(itemId);

                    if (!item) {
                        console.error(`Click handler: Item ${itemId} not found in dataset. This indicates a vis.js bug or data corruption.`);
                        return;
                    }

                    // Construct GitLab URL based on item type
                    let url = null;

                    if (item.projectId && item.pipelineId && item.jobId) {
                        // Job item - link to job page
                        url = `${CONFIG.gitlabUrl}/${item.projectId}/-/jobs/${item.jobId}`;
                        console.log(`Opening job ${item.jobId} in project ${item.projectId}`);
                    } else if (item.projectId && item.pipelineId) {
                        // Pipeline item - link to pipeline page
                        url = `${CONFIG.gitlabUrl}/${item.projectId}/-/pipelines/${item.pipelineId}`;
                        console.log(`Opening pipeline ${item.pipelineId} in project ${item.projectId}`);
                    }

                    // Open URL in new tab if available
                    if (url) {
                        window.open(url, '_blank', 'noopener,noreferrer');
                    }
                }
            });

            console.log('Timeline initialized successfully');
        }


        /**
         * Schedule auto-refresh if enabled in configuration
         */
        function scheduleAutoRefresh() {
            // Clear any existing timer
            if (refreshTimer) {
                clearTimeout(refreshTimer);
                refreshTimer = null;
            }

            // Check if auto-refresh is enabled
            if (!CONFIG.refreshInterval || CONFIG.refreshInterval <= 0) {
                console.log('Auto-refresh disabled (refreshInterval <= 0)');
                return;
            }

            console.log(`Scheduling auto-refresh in ${CONFIG.refreshInterval} seconds`);

            // Schedule next refresh
            refreshTimer = setTimeout(async () => {
                console.log('Auto-refresh triggered');
                await fetchAndRender(true); // Pass isRefresh=true
                scheduleAutoRefresh(); // Schedule next refresh
            }, CONFIG.refreshInterval * 1000);
        }

        /**
         * Fetch GitLab data and render on timeline
         *
         * Orchestrates the complete data flow:
         * 1. Fetch projects from GitLab API
         * 2. Fetch pipelines for those projects
         * 3. Fetch jobs for those pipelines
         * 4. Transform to vis.js format
         * 5. Update timeline with transformed data
         *
         * @param {boolean} isRefresh - If true, indicates this is a refresh operation
         */
        async function fetchAndRender(isRefresh = false) {
            try {
                // Indicate refresh is in progress
                if (isRefresh) {
                    updateLastUpdateTimestamp(true);
                }

                // Step 1: Fetch projects
                const loadingMsg = isRefresh ? 'Refreshing data...' : 'Fetching projects from GitLab...';
                showLoading(loadingMsg);
                const projects = await apiClient.fetchProjects();

                // Update global project map for enrichment
                projectMap.clear();
                projects.forEach(p => projectMap.set(p.id, p));

                // Step 2: Fetch pipelines
                showLoading(`Fetching pipelines from ${projects.length} projects...`);
                const pipelines = await apiClient.fetchPipelines(projects, CONFIG.updatedAfter);

                if (pipelines.length === 0) {
                    if (isRefresh) {
                        // Update timestamp even when no new pipelines
                        updateLastUpdateTimestamp(false);

                        // Expected: no new updates since last refresh
                        updateStatus(
                            `<strong>No new pipelines</strong><br>` +
                            `No pipeline updates since ${CONFIG.since}.<br>` +
                            'This is normal - the chart will update automatically when new pipelines run.',
                            'success'
                        );
                    } else {
                        // Actual problem: no data in time range
                        updateStatus(
                            '<strong>No pipelines found</strong><br>' +
                            `No pipelines found in the specified time range (since ${CONFIG.since}).<br>` +
                            'Try adjusting the time range or check if pipelines exist in the configured projects.',
                            'warning'
                        );
                    }
                    return;
                }

                // Step 3: Fetch jobs
                showLoading(`Fetching jobs from ${pipelines.length} pipelines...`);
                const jobs = await apiClient.fetchJobs(pipelines);

                // Store unfiltered data for re-filtering
                unfilteredPipelines = pipelines;
                unfilteredJobs = jobs;

                // Apply filters using shared computation function
                const { filteredPipelines, filteredJobs } = computeFilteredData();

                // Step 4: Transform to vis.js format (using filtered data, pass projectMap for project-based grouping)
                showLoading('Transforming data for visualization...');
                const transformed = DataTransformer.transform(filteredPipelines, filteredJobs, projectMap);

                // Step 4a: Calculate resource contention and create background items (using filtered data)
                const domainModel = DataTransformer.transformToDomainModel(filteredPipelines, filteredJobs, projectMap);
                const allPipelines = domainModel.flatMap(user => user.pipelines);
                const contentionPeriods = ContentionAnalyzer.calculateContentionPeriods(allPipelines);
                const contentionBackgrounds = ContentionAnalyzer.toVisBackgroundItems(contentionPeriods);

                // Step 5: Enrich pipeline items with project names and job items with project context
                const enrichedItems = enrichTimelineItems(transformed.items, filteredPipelines, filteredJobs, projectMap);

                // Step 6: Combine enriched items with contention backgrounds
                const allItems = [...enrichedItems, ...contentionBackgrounds];

                // Step 7: Update timeline
                showLoading('Rendering timeline...');

                // Preserve view state during auto-refresh to avoid disrupting user experience
                let savedWindow = null;
                let expandedGroups = null;
                if (isRefresh && timeline) {
                    // Save current viewport position
                    savedWindow = timeline.getWindow();

                    // Save which groups are expanded
                    expandedGroups = new Set();
                    const currentGroups = timeline.groupsData.get();
                    currentGroups.forEach(group => {
                        if (group.showNested === true) {
                            expandedGroups.add(group.id);
                        }
                    });
                    console.log(`State preservation: saved ${expandedGroups.size} expanded groups:`, Array.from(expandedGroups));

                    // Restore expansion state BEFORE setting groups
                    if (expandedGroups && expandedGroups.size > 0) {
                        let restoredCount = 0;
                        transformed.groups.forEach(group => {
                            if (expandedGroups.has(group.id)) {
                                group.showNested = true;
                                restoredCount++;
                                console.log(`State preservation: restoring expansion for group ${group.id}`);
                            }
                        });
                        console.log(`State preservation: restored ${restoredCount} groups out of ${expandedGroups.size} saved`);
                    }
                }

                // Update data (groups are already configured with correct showNested state)
                timeline.setGroups(transformed.groups);
                timeline.setItems(allItems);

                // Restore viewport position during auto-refresh
                if (isRefresh && savedWindow) {
                    // Restore viewport position (prevent jarring jumps)
                    timeline.setWindow(savedWindow.start, savedWindow.end, {animation: false});
                }

                // Update last update timestamp
                updateLastUpdateTimestamp(false);

                // Update time range label (refresh current time)
                updateTimeRangeLabel();

                // Success message
                const actionWord = isRefresh ? 'refreshed' : 'loaded';
                const successMessage =
                    `<strong>Data ${actionWord} successfully</strong><br>` +
                    `Loaded ${projects.length} projects, ${pipelines.length} pipelines, ${jobs.length} jobs<br>` +
                    `Time range: ${CONFIG.since}`;
                updateStatus(successMessage, 'success');

            } catch (error) {
                console.error('Error fetching and rendering data:', error);
                const errorMessage = formatError(error);
                updateStatus(errorMessage, 'error');

                // Log full error details for debugging
                if (error.originalError) {
                    console.error('Original error:', error.originalError);
                }
            }
        }
    </script>
</body>
</html>
